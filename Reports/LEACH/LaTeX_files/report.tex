\documentclass[12pt,a4paper]{report}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage[top=7mm,bottom=15mm,left=15mm,right=15mm,headheight=17pt,includehead,includefoot,heightrounded]{geometry} 
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english,greek]{babel}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% COMMANDS %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\eng}[1]{{\selectlanguage{english}#1}}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{\small ΠΛΗ 516 : Εργασία \eng{TinyOS}}
\fancyfoot[R]{\small \thepage\ από \pageref{LastPage}}
\setlength{\headsep}{35pt}
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{1pt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{titlepage}
\centering
\selectlanguage{greek}
{\huge\bf Εργασία \eng{TinyOS} \par}
\vspace{0.3cm}
{\Large\bf 2η Φάση \par}
\vspace{0.3cm}
{\normalsize Ημερομηνία Παράδοσης : 8 Δεκεμβρίου 2017\par}
\vspace{6cm}
{\large Επεξεργασία και Διαχείριση Δεδομένων σε Δίκτυα Αισθητήρων\par}
\vspace{1cm}
{\large Διδάσκων : A. Δεληγιαννάκης\par}
\vfill
{\large Σταματάκης Γεώργιος - 2013030154\par}
\vspace{0.2cm}
{\large Σκυβαλάκης Κωνσταντίνος - 2013030034\par}
\vspace{0.2cm}
\eng{{\large GitHub exercise repo : \url{https://github.com/gstamatakis/SensorsTinyOS}\par}}
\end{titlepage}

\newpage
\section*{Πρόγραμμα 2}

\subsection*{Προσθήκες κώδικα}
Για τον κώδικα του προγράμματος 2 διατηρήσαμε τον \eng{routing tree} αλγόριθμο που χρησιμοποιήσαμε στην 1η φάση για το \eng{TAG}. Στη συνέχεια, προσθέσαμε κώδικα στη βιβλιοθήκη \eng{SimpleRoutingTree.h} σχετικά με τα μηνύματα των \eng{advertisements} που στέλνουν οι \eng{Cluster Heads (CH)} καθώς επίσης και για τα μηνύματα των \eng{advertisement response} που κάνουν οι κόμβοι που λαμβάνουν τις διαφημίσεις και αποφασίζουν να ορίσουν τον εκάστοτε \eng{CH} ως ηγέτη τους για να του στέλνουν τις μετρήσεις τους. Ακόμη, προσθέσαμε κάποιους \eng{timers} σχετικούς με την υλοποίηση του \eng{LEACH} (π.χ. χρονική διάρκεια του γύρου). Επιπλέον, όπως και στην 1η φάση προσθέσαμε και στο αρχείο \eng{SRTreeAppC.nc} τις απαραίτητες αλλαγές για να μπορούμε να χρησιμοποιήσουμε τις καινούριες ουρές μηνυμάτων που θα φτιάξουμε, τους \eng{timers} καθώς επίσης και τα ίδια τα μηνύματα.\\

Οι σημαντικότερες αλλαγές και προσθήκες κώδικα που κάναμε είναι αυτές που έγιναν στο αρχείο \eng{SRTreeC.nc} και είναι οι εξής :

\begin{itemize}
\item Συνάρτηση εκλογής \eng{CH}
\item Συγχρονισμός \eng{timers}
\item Αποστολή \eng{Ad} μηνυμάτων και \eng{responses} αυτών
\end{itemize}

Ο σχεδιασμός της υλοποίησης μας βασίστηκε πάνω στα 3 παρακάτω κομμάτια της κάθε εποχής :
\begin{enumerate}
\item Οι \eng{CHs} στέλνουν τα \eng{advertise} μηνύματα.
\item Οι \eng{Non-CH} κόμβοι κάνουν \eng{join} τον \eng{CH} που επιλέγουν.
\item Υπολογισμός \eng{Aggregate Queries}.
\end{enumerate}

Αναλυτικότερα σχετικά με τη συνάρτηση εκλογής των \eng{CH}. Η συνάρτηση καλείται μόνο μια φορά σε κάθε γύρο μιας και οι \eng{CHs} που εκλέγονται παραμένουν σταθεροί μέχρι το τέλος του γύρου. Αυτό που επιστρέφει είναι μια \eng{boolean} μεταβλητή η οποία δηλώνει αν ο κόμβος ο οποίος την κάλεσε είναι \eng{CH}. Η διαδικασία εκλογής των\eng{CHs} βασίζεται εξ'ολοκλήρου σε αυτά που περιγράφει το \eng{paper} του \eng{LEACH}. Πιο συγκεκριμένα για να ελέγξουμε αν ο κάθε κόμβος είναι \eng{CH} σε αυτόν τον γύρο, ελέγχουμε αν ήταν \eng{CH} τους τελευταίους $1/P$ γύρους και αν ο τυχαίος αριθμός που ''τράβηξε'' ο κόμβος στο διάστημα $[0,1]$ είναι μικρότερος από το \eng{threshold} που αναγράφεται στο \eng{paper}.\\

Στην πρώτη φάση της εποχής, για την αποστολή των \eng{ad} μηνυμάτων δημιουργήσαμε τις απαραίτητες ουρές, \eng{timers} και \eng{events}. Αν ένας κόμβος είναι \eng{CH} τότε κάνει \eng{broadcast} τα \eng{ads} του και όσοι τον ακούνε αποφασίζουν αν θα τον επιλέξουν για ηγέτη. Στη δεύτερη φάση, οι υπόλοιποι κόμβοι που δεν είναι ηγέτες, επιλέγουν τον ηγέτη τους τον οποίο και διατηρούν μέχρι τις επόμενες εκλογές και του προωθούν τα δεδομένα τους. Στην τρίτη και τελευταία φάση, αν ο κόμβος που ελέγχεται είναι \eng{CH} τότε προσθέτει και τα δικά του δεδομένα στο πακέτο και απλά προωθεί τα δεδομένα που έχει συλλέξει προς τα πάνω στο δέντρο με τελικό προορισμό τη ρίζα. Αν ο κόμβος που ελέγχεται δεν είναι \eng{CH}, τότε προσθέτει και αυτός τα δικά του δεδομένα στο πακέτο και το προωθεί προς τον \eng{CH} του είτε απευθείας είτε μέσω ενδιάμεσων κόμβων.\\

\newpage
Σύμφωνα με τη δομή της εποχής που ορίσαμε παραπάνω έτσι και στον συγχρονισμό των \eng{timers}, ελέγξαμε ο \eng{timer} των \eng{ads} να χτυπάει μόνο μια φορά σε κάθε γύρο ενώ οι απαντήσεις των κόμβων σε ένα \eng{ad} μπορεί να συμβούν πολλές φορές μέσα σε ένα γύρο,μιας και έχει να κάνει σχέση με την επιλογή του ηγέτη και  την προώθηση των δεδομένων των κόμβων, εξού και ο \eng{timer} που χρησιμοποιείται. Τέλος, ο \eng{MsgTimer} έχει να κάνει σχέση με την προώθηση των δεδομένων (ανεξαρτήτως κόμβου) σε στιγμές που δε χρειάζεται να γίνει επιλογή ηγέτη από τους κόμβους.\\

\subsection*{Αφαίρεση κώδικα}
Γενικά, αφαιρέσαμε πολύ μικρά σε έκταση κομμάτια κώδικα, μόνο ίσως κάτι μικρές λεπτομέρειες που θα μπορούσαμε να είχαμε αφαιρέσει από την πρώτη φάση χωρίς να επηρεάζεται το αποτέλεσμα, όπως π.χ. κάποια \eng{else if} που δεν εκτελούνταν ποτέ. 


\section*{Παραπομπές σε Κώδικα}
Λόγω της μεγάλης έκτασης του σημαντικού κατά εμάς κώδικα, δε θα παραθέσουμε \eng{screenshots}, αλλά αντί αυτού παραπομπές σε σημεία της υλοποίησης μας τα οποία θεωρούμε σημαντικά. Τα παρακάτω κομμάτια κώδικα παρέχονται με αρκετά σχόλια και είναι ουσιαστικά ενσωματωμένα στην ανάλυση παραπάνω. \\

\begin{itemize}
\item \eng{bool IamClusterhead()} , γραμμή : 871
\item \eng{task void receiveAdResponseTask()} , γραμμή : 834
\item \eng{event void AdResponseTimer.fired()} , γραμμή : 524
\item \eng{event void AdResponseTimer.fired()} , γραμμή : 463
\item \eng{event void AdTimer.fired()} , γραμμή : 404
\end{itemize}

Να προσθέσουμε ότι στα \eng{ad responses} που συλλέγει ο \eng{CH} διατηρούμε όπως και στην πρώτη φάση του πρότζεκτ μια μικρή \eng{cache} με τις τελευταίες τιμές που έχουμε συλλέξει, έτσι ώστε να δίνουμε όσο το δυνατό σωστότερα αποτελέσματα σε περιπτώσεις αποτυχίας αποστολής ή λήψης κάποιων μηνυμάτων.

\newpage
\section*{Αποτελέσματα}
Παραθέτουμε μαζί με τα αρχεία της εργασίας ένα αρχείο που βρίσκεται στον φάκελο \eng{Logs} με όνομα \eng{logfile\_25nodes\_LEACH.txt} το οποίο περιλαμβάνει τα αποτελέσματα της εκτέλεσης για μια εποχή τα οποία και σχολιάζουμε παρακάτω. Να σημειωθεί ότι το \eng{topology} έχει διατηρηθεί ίδιο με την πρώτη φάση της εργασίας.\\
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{root_adsend.png}
\caption{\eng{Root as a CH sends the first ad message.}}
\vspace{1cm}
\includegraphics[scale=0.8]{ad_receive.png}
\caption{\eng{Advertisement receive from root.}}
\vspace{1cm}
\includegraphics[scale=0.8]{ch_election.png}
\caption{\eng{Node 1 CH election.}}
\end{figure}

Στο σχήμα 1 η ρίζα (0) στέλνει το πρώτο \eng{ad} μήνυμα σας γνωστός \eng{CH}, ενώ στο σχήμα 2 οι κόμβοι 6,5 και 1 λαμβάνουν το \eng{ad} μήνυμα της ρίζας την οποία και επιλέγουν ως ηγέτη τους. Στο σχήμα 3, ο κόμβος 1 εκλέγεται ηγέτης μιας και δεν είχε ξαναεκλεγεί τους τελευταίους $1/P$ γύρους και πληροί την προϋπόθεση του \eng{threshold}. Υπάρχει περίπτωση κάποιος κόμβος να απορρίψει κάποιον άλλο κόμβο $j$ για ηγέτη του αν ο ίδιος είναι ηγέτης με το εξής μήνυμα : \eng{Discarding received Ad from $j$ because I am a CH!}. Όπως επίσης μπορεί και κάποιος κόμβος να μην εκλεγεί ηγέτης, όπου τότε ενημερώνει με το αντίστοιχο μήνυμα : \eng{I am NOT a CH!}. Η παραπάνω διαδικασία συνεχίζεται μέχρις ώτου έχουν εκλεγεί όλοι οι \eng{CHs} και τότε αρχίζουν τα \eng{ad response} μηνύματα με τις μετρήσεις του κάθε κόμβου.

\newpage
\begin{figure}[t]
\centering
\includegraphics[scale=0.8]{adresponse.png}
\caption{\eng{Node 24 ad response to node 23.}}
\end{figure}

Στο σχήμα 4, ο κόμβος 24 προωθεί τα δεδομένα του στον κόμβο 23 και έτσι ο κόμβος 23 ξέρει ότι ο 24 τον έχει επιλέξει ως ηγέτη.

\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{root_results.png}
\caption{\eng{Root prints the results of epoch 1.}}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{msg_query.png}
\caption{\eng{Node 5 forwards his data.}}
\end{figure}

Στο σχήμα 6 ο κόμβος 5 προωθεί τα δεδομένα τους στον \eng{CH} του που είναι ο 0, η ρίζα δηλαδή. Επιπλέον, σε αυτό το κομμάτι βλέπουμε την 3η φάση που περιγράψαμε παραπάνω.\\

\newpage
\begin{figure}
\centering
\includegraphics[scale=0.8]{msg_query2.png}
\caption{\eng{CH node 15 forwards his data.}}
\end{figure}
Στο σχήμα 7 ο κόμβος 15 που είναι και \eng{CH} προωθεί με τη σειρά του τα δεδομένα του μαζί και των υποδέντρων του προς τα πάνω στο δέντρο μέσω του κόμβου 10 ο οποίος δεν είναι \eng{CH} (θα μπορούσε και να ήταν) και τελικό προορισμό τη ρίζα. \\


Για λόγους ευκολίας και καλύτερης κατανόησης των μηνυμάτων στο \eng{logfile} παραθέτουμε το δέντρο που έχει προκύψει μετά το \eng{routing}. Υπενθυμίζουμε ότι όπως και στην πρώτη φάση τα \eng{ID} των κόμβων που φαίνονται στο δέντρο είναι αυτά που αναγράφονται μείον 1 λόγω \eng{MATLAB}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{routingtree}
\caption{\eng{Topology of sensors after routing.}}
\end{figure}



\section*{Καταμερισμός Εργασιών}
Τα παραπάνω κομμάτια της δεύτερης φάσης της εργασίας ολοκληρώθηκαν με δίκαιο καταμερισμό και συνεργασία σε κάθε στάδιο. Όλοι οι κώδικες συγγράφηκαν από κοινού ενώ και οι δυο μας προτείναμε διορθώσεις και διαφορετικές λύσεις ο ένας στον άλλο σε κάποιες περιπτώσεις.

\begin{thebibliography}{3}

\eng{
\bibitem{1}
Energy-Efficient Communication Protocol for Wireless Microsensor Networks\\
\url{https://www.gta.ufrj.br/wsns/Routing/leach.pdf}}


\end{thebibliography}

\end{document}