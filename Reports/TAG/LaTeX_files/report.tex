\documentclass[12pt,a4paper]{report}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage[top=7mm,bottom=15mm,left=15mm,right=15mm,headheight=17pt,includehead,includefoot,heightrounded]{geometry} 
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english,greek]{babel}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% COMMANDS %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\eng}[1]{{\selectlanguage{english}#1}}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{\small ΠΛΗ 516 : Εργασία \eng{TinyOS}}
\fancyfoot[R]{\small \thepage\ από \pageref{LastPage}}
\setlength{\headsep}{35pt}
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{1pt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{titlepage}
\centering
\selectlanguage{greek}
{\huge\bf Εργασία \eng{TinyOS} \par}
\vspace{0.3cm}
{\Large\bf 1η Φάση \par}
\vspace{0.3cm}
{\normalsize Ημερομηνία Παράδοσης : 24 Νοεμβρίου 2017\par}
\vspace{6cm}
{\large Επεξεργασία και Διαχείριση Δεδομένων σε Δίκτυα Αισθητήρων\par}
\vspace{1cm}
{\large Διδάσκων : A. Δεληγιαννάκης\par}
\vfill
{\large Σταματάκης Γεώργιος - 2013030154\par}
\vspace{0.2cm}
{\large Σκυβαλάκης Κωνσταντίνος - 2013030034\par}
\vspace{0.2cm}
\eng{{\large GitHub exercise repo : \url{https://github.com/gstamatakis/SensorsTinyOS}\par}}
\end{titlepage}

\newpage
\section*{Βοηθητικό Πρόγραμμα}

Για να φτιάξουμε τα δικά μας $topology.txt$ αρχεία γράψαμε έναν κώδικα σε \eng{Python} ο οποίος δέχεται ώς ορίσματα το ${\bf D}$ και το ${\bf r}$ τα οποία υποδηλώνουν το μέγεθος (\eng{dimension}) του \eng{grid} που θα δημιουργηθεί και την εμβέλεια (\eng{range}) των αισθητήρων αντίστοιχα.\\

Αρχικά, δημιουργούμε το \eng{grid} ώς έναν $D\times D$ πίνακα που περιέχει τιμές στο σύνολο $\{0,1,...,D^2-1\}$ οι οποίες τιμές αντιστοιχούν στο \eng{TOS\_NODE\_ID} του κάθε κόμβου. Όπως ζητείται από την εκφώνηση, με το παρακάτω \eng{arrangement} ο κάθε κόμβος $j$ θα ανήκει στη γραμμή $j/D$ και στη στήλη $j\%D$. Η μορφή του \eng{grid} για $D=4$ θα είναι η παρακάτω.

\begin{center}
$
grid =
\begin{bmatrix}
    0 & 1 & 2 & 3 \\
    4 & 5 & 6 & 7 \\
    8 & 9 & 10 & 11 \\
    12 & 13 & 14 & 15 \\
\end{bmatrix}
$
\end{center}

Αφότου δημιουργήσαμε το \eng{grid} μας δημιουργήσαμε και μια συνάρτηση που υπολογίζει τους γείτονες κάθε κόμβου την οποία ονομάσαμε $find\_neighbors(m, i, j, r, d)$ και της οποίας τα ορίσματα αντιστοιχούν σε :
\begin{itemize}
\item \eng{m} : ο πίνακας του \eng{grid} που φτιάξαμε πριν
\item \eng{i} : το \eng{index} γραμμής του κόμβου του οποίου τους γείτονες αναζητάμε
\item \eng{j} : το \eng{index} στήλης του κόμβου του οποίου τους γείτονες αναζητάμε
\item \eng{r} : η εμβέλεια των αισθητήρων
\item \eng{d} : η διάσταση του \eng{grid}
\end{itemize}

Για να αποφανθεί η συνάρτηση αν κάποιος άλλος κόμβος είναι εντός εμβέλειας του αισθητήρα που εξετάζουμε και κατά συνέπεια να τον προσθέσει ως γείτονα λαμβάνει την ευκλείδεια απόσταση τους (με βάση τα \eng{index}) ώς εξής :

\begin{equation}
d(p,q)=\sqrt{(i-x)^2 + (j-y)^2}
\end{equation}
\vspace{.05cm}

Όπου $p$, ο κόμβος του οποίου τους γείτονες αναζητάμε και $q$ ο κόμβος με τον οποίο ελέγχουμε σε κάθε χρονική στιγμή αν είναι γείτονας του $p$. Τα $(x,y)$ είναι τα αντίστοιχα \eng{indices} του κόμβου $q$.\\

Τέλος, αφού το πρόγραμμα έχει υπολογίσει τους γείτονες όλων των κόμβων, τους γράφει σε ένα αρχείο $topology.txt$ το οποίο και χρησιμοποιούμε στο \eng{simulation} μας.


\newpage
\section*{Πρόγραμμα 1}

\subsection*{Αφαίρεση κώδικα}
Κύριος στόχος μας στην ανάπτυξη του κώδικα ήταν η οικονομία στο μέγεθος και στην αποστολή μηνυμάτων κατά το βέλτιστο δυνατό, μιας και η λειτουργία του πομποδέκτη του αισθητήρα κοστίζει σε μπαταρία πολύ περισσότερο απ'ότι μερικές παραπάνω γραμμές κώδικα.\\

Αρχικά, αφαιρέσαμε ότι κομμάτια κώδικα δεν μας χρειάζονταν, όπως κομμάτια κώδικα που δεν σχετίζονται με την υλοποίηση του \eng{TAG} καθώς επίσης και κομμάτια κώδικα τα οποία δεν πρόκειται να εκτελεστούν ποτέ. Πιο συγκεκριμένα, αφαιρέσαμε τα \eng{modules} του \eng{serial} (\eng{interfaces, events, timers}, κλπ.) που σχετίζονται με επικοινωνία του αισθητήρα μέσω σειριακής θύρας κάτι το οποίο δε μας χρειάζεται. Ακόμη, αφαιρέσαμε ότι σχετίζεται με την λειτουργία των \eng{LEDs} (\eng{events, timers}, κλπ.) μιας και σε \eng{simulation mode} δεν πρόκειται επίσης να μας χρειαστούν.\\

Σημαντική αφαίρεση κομματιού κώδικα ήταν τα μηνύματα \eng{notify} και ότι σχετίζεται με αυτά όπως (\eng{interfaces, events, queues}, κλπ.). Ο λόγος για τον οποίο τα αφαιρέσαμε είναι διότι είμαστε σε \eng{simulation mode} και γνωρίζουμε ότι κανένας από τους κόμβους δεν πρόκειται να πεθάνει. Μιας και κανένας κόμβος δεν πεθαίνει δε χρειάζεται να ξαναγίνει \eng{re-routing} του δέντρου και αλλαγή πατεράδων. Ως συνέπεια, οι κόμβοι δε χρειάζεται να στέλνουν \eng{notify} μηνύματα στους πατεράδες τους. Τέλος, ένας κόμβος καταλαβαίνει ότι ένας άλλος κόμβος είναι παιδί του από το μήνυμα των μετρήσεων που του στέλνει, καθώς κάθε μήνυμα στο \eng{TinyOS} έχει στοιχεία του αποστολέα στην κεφαλήδα του πακέτου και ο παραλήπτης κόμβος διατηρεί μια λίστα με τα παιδιά του από τη διαδικασία του \eng{routing} που γίνεται στην αρχή, οπότε και αναγνωρίζει αν το μήνυμα είναι από κάποιο παιδί του.

\subsection*{Προσθήκη κώδικα}
Στόχος μας ήταν να ελαχιστοποιήσουμε τα μηνύματα που χάνονταν και να προσπαθήσουμε παρόλο τις απώλειες να διατηρήσουμε ένα σχετικά σωστό τελικό αποτέλεσμα στη ρίζα. Ο κώδικας που προσθέσαμε είναι για τα εξής κομμάτια :

\begin{itemize}
\item Παραγωγή τυχαίων \eng{readings} στο διάστημα $[K,K+20]$, όπου $K=TOS\_NODE\_ID$
\item Αποστολή και λήψη των \eng{query} μηνυμάτων
\item Κατασκευή μικρής μνήμης \eng{Cache} για κάθε κόμβο
\item Συγχρονισμός \eng{timers}
\end{itemize}

Πιο συγκεκριμένα, έχουμε θέσει τον κάθε κόμβο να παράγει μια μέτρηση κάθε 60\eng{sec} που είναι και η διάρκεια της εποχής. Αρχικά, για να σιγουρευτούμε ότι όλα πήγαιναν καλά και μόνο για λόγους δοκιμής, είχαμε θέσει η μέτρηση που παρήγαγαν οι κόμβοι να είναι ίση με $10$ και προφανώς ως αποτέλεσμα περιμέναμε να δούμε διασπορά(\eng{var}) ίση με $0$ και μέση τιμή (\eng{avg}) ίση με $10$. Αφού σιγουρευτήκαμε ότι το \eng{routing} είχε γίνει σωστά, αφήσαμε τους κόμβους να παράγουν τυχαίες τιμές στο προκαθορισμένο διάστημα.\\

\newpage
Στη συνέχεια, δημιουργήσαμε τα δικά μας \eng{Active Messages} για την ανταλλαγή επερωτήσεων (\eng{queries}) στους κόμβους του δέντρου και τη συλλογή των δεδομένων με βάση το \eng{TAG}. Δημιουργήσαμε τα απαραίτητα \eng{tasks} και \eng{timers} για την επίτευξη αυτής της διαδικασίας. Η πληροφορία που προσθέτουμε εμείς στα \eng{routing} μηνύματα ειναι το \eng{senderID} και το \eng{curdepth}, δηλαδή το επίπεδο του κόμβου που στέλνει το μήνυμα. Στα \eng{query} μηνύματα στέλνουμε το \eng{count} που είναι το πλήθος των κόμβων που συμμετέχουν μέχρι στιγμής στο \eng{aggregation}, το \eng{sum} που είναι το συνολικό άθροισμα μέχρι στιγμής και τέλος το \eng{sum\_squared} το οποίο το χρησιμοποιούμε για τον υπολογισμό του \eng{variance}. Οι παρακάτω τύποι δείχνουν αναλυτικότερα τον υπολογισμούς :

\begin{equation}
\begin{split}
avg &= \frac{sum}{count}\\
\\
var &= \frac{sum\_squared}{count}-avg^2
\end{split}
\end{equation}
\vspace{.05cm}

Αυτοί οι υπολογισμοί πραγματοποιούνται μόνο από την ρίζα ενώ όλοι οι υπόλοιποι κόμβοι απλώς προωθούν ένα μήνυμα στον πατέρα τους με τις τιμές που έχουν συλλέξει μέχρι στιγμής.\\

Παρατηρούμε ότι πάντοτε, ειδικά για μεγάλες τιμές του $D$ όπου το πλήθος των κόμβων αυξάνεται αισθητά, χάνονται πακέτα. Για να ελαχιστοποιήσουμε αυτές τις απώλειες δημιουργήσαμε μια μικρή μνήμη \eng{Cache} σε κάθε κόμβο η οποία κρατάει τις τελευταίες μετρήσεις των παιδιών του και τις χρησιμοποιεί όταν χαθεί κάποιο μήνυμα από αυτά. Έτσι, παρόλο τις απώλειες επιτυγχάνεται μεγαλύτερη ακρίβεια τελικών αποτελεσμάτων.\\

Τέλος, ένα αρκετά \eng{challenging task} ήταν ο κατάλληλος συγχρονισμός των \eng{timers}. Η σωστή αποστολή και λήψη μηνυμάτων απαιτεί καλό συγχρονισμό διότι αν ένας κόμβος δεν στέλνει τις σωστές χρονικές στιγμές (περιοδικά) το μήνυμα του υπάρχει κίνδυνος να χαθούν μηνύματα και να αλοιωθούν τα τελικά αποτελέσματα.

\begin{equation}
\begin{split}
start=-MUL*(curdepth*TFP + TVM*TNI+rand()\%10*MUL);\\
\\
start=-MUL*((curdepth-1)*TFP + TVM*TNI+rand()\%10*MUL);
\end{split}
\end{equation}

Όπου :

\begin{equation}
\begin{split}
TFP &: TIMER\_FAST\_PERIOD=200\\
TVM &: TIMER\_VFAST\_MILI=EPOCH / 1000\\
TNI &: TOS\_NODE\_ID \in \{1,2,...\}
\end{split}
\end{equation}

Οι παραπάνω τύποι μας δίνουν τον χρόνο εκκίνησης των μετρητών όλων των κόμβων εκτός του \eng{root} για δυο διαφορετικές περιπτώσεις. Η πρώτη περίπτωση αφορά το ενδεχόμενο που βρισκόμαστε ακόμα στα πρώτα στάδια του προγράμματος που οι κόμβοι δεν έχουν όλοι αποκτήσει πατέρα (\eng{routing}), ενώ η δεύτερη περίπτωση αφορά το ενδεχόμενο ο κόμβος να έχει πατέρα οπότε και αλλάζει ελαφρώς ο τύπος. Σημαντικό επίσης είναι να αναφέρουμε ότι οι περιοδικοί \eng{timers} με αρνητική τιμή θα έχουν διάφορα σειριακά \eng{events} μέχρις ωτου κάνουν \eng{"catch up"} στην τωρινή κατάσταση και επίσης να πούμε ότι όλοι οι \eng{timers} αναδιπλώνονται. Ακόμη, κλιμακώνουμε τον χρόνο \eng{start} για να γινει μικροτερη η πιθανοτητα να χαθει μήνυμα. Τέλος, η προσθήκη της \eng{rand()} είναι μια ακόμη προσπάθεια για ελαχιστοποίηση συγκρούσεων. Αρκετά βοηθητικό στον συγχρονισμό ήταν το παρακάτω σχήμα του \eng{TAG}.


\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{tag_levels}
\caption{\eng{Partial state records flowing up the tree during an epoch.}}
\end{figure}

\newpage
\section*{\eng{Screenshots} Κώδικα}
Παρακάτω παραθέτουμε μερικά κομμάτια κώδικα τα οποία θεωρούμε σημαντικά.\\

\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{srth}
\caption{\eng{SimpleRoutingTree.h library file.}}
\end{figure}
Στο παραπάνω \eng{screenshot} φαίνονται οι αλλαγές και οι προσθήκες που έχουμε κάνει στο αρχείο \eng{SimpleRoutingTree.h} όπως ότι θέσαμε ένα μέγιστο αριθμό παιδιών, προσθέσαμε μια λίστα για τις τιμές των παιδιών του κάθε κόμβου και μια για το μήνυμα του ίδιου, αφαιρώντας τις λίστες για τα \eng{notify} μηνύματα όπως άλλωστε έχουμε πει και σε προηγούμενο στάδιο της αναφοράς.


\begin{figure}
\centering
\includegraphics[scale=0.7]{reads}
\caption{\eng{Random value generation every time the ReadingTimer is fired.}}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.7]{query_msg}
\caption{\eng{Query message contents and computation of aggregate functions.}}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.7]{cache}
\caption{\eng{Cache creation and latest values storage.}}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.7]{rout_msg}
\caption{\eng{Routing message contents.}}
\end{figure}


\newpage
\section*{Αποτελέσματα}
Αρχικά, τροποποιήσαμε το αρχείο \eng{mySimulation.py} και θέσαμε ότι στο \eng{simulation} που ακολουθεί θα έχουμε 25 κόμβους ($D=5$) με \eng{range}=1.5. Επίσης, να σημειώσουμε ότι έχουμε αλλάξει με δικά μας κάποια από τα \eng{debug} μηνύματα που τυπώνονται για λόγους καλύτερης κατανόησης της ροής του \eng{output}. Παραθέτουμε μαζί με τα αρχεία της εργασίας ένα αρχείο με όνομα \eng{logfile\_sim\_25.txt} το οποίο περιλαμβάνει τα αποτελέσματα της εκτέλεσης τα οποία σχολιάζουμε παρακάτω.\\

Στην αρχή του $logfile$ υπαρχουν αρκετά όμοια μηνύματα που έχουν να κάνουν σχέση με το \eng{routing} των κόμβων. Παρακάτω όμως, συναντάμε μηνύματα όπως τα εξής :\\

$EPOCH:2-> sum: 399 | count: 20 | sum\_squared: 9569 | avg: 19.95 | var: 80.45$\\

Τέτοιου τύπου μηνύματα μας δηλώνουν το τέλος μιας εποχής και συνάμα τι αποτελέσματα είχαμε σε αυτόν τον γύρο. Μιας και οι κόμβοι παίρνουν τυχαίες τιμές στο διάστημα $[K,K+20]$ μπορούμε με χρήση πιθανοτήτων να υπολογίσουμε το αναμενόμενο αποτέλεσμα και να επαληθεύσουμε κατά πόσο είμαστε σωστοί.\\

Η μέση τιμή που περιμένουμε να έχει ένας κόμβος $X_K$ είναι η εξής : 

\begin{center}
$$Ε[X_K]=\sum_{i=K}^{K+20}p_{X_K}(i)\cdot i=\frac{1}{20}\sum_{i=K}^{K+20}i=\frac{K^2+41K+420}{40}$$
\end{center}
\vspace{.5cm}

Συνολικά για ένα δίκτυο $N$ κόμβων περιμένουμε να έχουμε τελική μέση ίση με την παρακάτω :

\begin{center}
$$Ε[X]=Ε[X_1 + X_2 + ... X_N]=\frac{1}{N}\sum_{i=1}^{Ν}E[X_i]=\frac{1}{N}\sum_{i=1}^{Ν}\frac{i^2+41i+420}{40}$$
\end{center}


Tέλος, έχουμε και μηνύματα της παρακάτω δομής.

\begin{flushleft}
$MsgTimer fired!$\\
$MsgTimer.fired(): Task posted.$\\
$sendQueryTask(): QueryAMSend.send success!$\\
$QueryReceive.receive from \ i$\\
$QueryAMSend.sendDone: True$
\end{flushleft}

Τέτοιου τύπου μηνύματα μας λένε ότι αρχικά χτυπάει ο \eng{timer} για να ετοιμάσουμε και να στείλουμε το μήνυμα με τις μετρήσεις του κόμβου και στη συνέχεια κάνουμε \eng{post} το \eng{task} της αποστολής του μηνύματος βάζοντας επιτυχώς το μήνυμα στην ουρά αποστολής. Στη συνέχεια, ο πατέρας του κόμβου, $i$, λαμβάνει το μήνυμα από το παιδί του και κάπου εκεί ολοκληρώνεται η διαδικασία αποστολής. Αφού ο πατέρας λάβει το μήνυμα το "ξεπακετάρει" προσθέτει με τη σειρά του τις δικές του μετρήσεις και των υπόλοιπων παιδιών του με σωστό τρόπο και το προωθεί παραπάνω κ.ο.κ. .

\newpage
Μέσα στο αρχείο $logfile\_sim\_25.txt$ φαίνονται κάποιες γραμμές όπως αυτές στην παρακάτω εικόνα.\\

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{routing}
\caption{\eng{Routing messages.}}
\end{figure}

Αυτό που μας λέει η παραπάνω εικόνα στις τρεις πρώτες γραμμές είναι ότι οι κόμβοι 6,5 και 1 έλαβαν μήνυμα για να κάνουν \eng{routing}, δηλαδή να διαλέξουν τον πατέρα τους. Στις επόμενες τρεις γραμμές βλέπουμε ότι οι κόμβοι 6,5 και 1 διάλεξαν και οι τρεις για πατέρας τους τον κόμβο 0, δηλαδή τη ρίζα του δένδρου.

\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{topo}
\caption{\eng{Topology of sensors.}}
\includegraphics[scale=0.6]{routingtree}
\caption{\eng{Topology of sensors after routing.}}
\end{figure}

\newpage
Το παραπάνω σχήμα (Σχήμα 8) δείχνει την τοποθέτηση των κόμβων και τις συνδέσεις μεταξύ όσων είναι γείτονες. Αφού γίνει το \eng{routing} ο κάθε κόμβος θα αποφασίσει ποιος θα είναι ο πατέρας του από τους γείτονες που έχει προφανώς. Το δένδρο που προκύπτει αφού γίνει το \eng{routing} φαίνεται επίσης παραπάνω (Σχήμα 9). Να σημειωθεί μόνο ότι η αρίθμηση των κόμβων λόγω \eng{MATLAB} ξεκινάει από το 1 και φτάνει μέχρι και το 25 ενώ θα έπρεπε να είναι από το 0 μέχρι το 24. Για να είναι απόλυτα ακριβές αυτό που βλέπουμε ουσιαστικά πρέπει να θεωρήσουμε το \eng{ID} του κάθε κόμβου να είναι αυτό που φαίνεται στα διαγράμματα μείον 1.


\section*{Καταμερισμός Εργασιών}
Oυσιαστικά το \eng{project} αποτελείται από 3 κομμάτια το βοηθητικό πρόγραμμα, το πρόγραμμα 1 (το μεγαλύτερο κομμάτι της εργασίας) και την αναφορά. Τα παραπάνω 3 κομμάτια ολοκληρώθηκαν με δίκαιο καταμερισμό και συνεργασία σε κάθε στάδιο. Όλοι οι κώδικες συγγράφηκαν από κοινού ενώ και οι δυο μας προτείναμε διορθώσεις ο ένας στον άλλο σε κάποιες περιπτώσεις.


\begin{thebibliography}{3}

\eng{
\bibitem{1}
TAG: a Tiny AGgregation Service for Ad-Hoc Sensor Networks\\
\url{https://www.usenix.org/legacy/publications/library/proceedings/osdi02/tech/full_papers/madden/madden_html/paperhtml.html}

\bibitem{2}
TinyOS Turorial 1\\
\url{http://cs.uccs.edu/~cs526/mote/tinyos/tutorial/lesson1.html}

\bibitem{3}
Modules and the TinyOS Execution Model\\
\url{http://tinyos.stanford.edu/tinyos-wiki/index.php/Modules_and_the_TinyOS_Execution_Model}
}

\end{thebibliography}

\end{document}